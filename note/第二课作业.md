## 第一题：实现嵌套路由

看了一下源码，跟着老师解答思路做的。。

```
# kvue-router.js

class KVueRouter {
    constructor(options) {
        // 保存选项
        this.$options = options

        // 设置一个响应式的current属性  【mark】
        // Vue.util.defineReactive(this, 'current', '/')
        Vue.util.defineReactive(this, 'matched', [])
        this.current = window.location.hash.slice(1) || '/'
        this.match()
        
        window.addEventListener('hashchange', this.onHashChange.bind(this))
        window.addEventListener('load', this.onHashChange.bind(this))

        // 对路由数组做预处理：转换为map
        // this.routeMap = {}
        // this.$options.routes.forEach(route => {
        //     this.routeMap[route.path] = route
        // })
        
    }

    onHashChange() {
        let hash = window.location.hash.slice(1)
        this.current = hash
        this.matched = []
        this.match()

        // console.log(this.matched)
    }

    match(routes) {
        routes = routes || this.$options.routes

        for (const route of routes) {
            if (route.path === '/' && this.current === '/') {
                this.matched.push(route)
                return;
            }
            
            if (route.path !== '/' && this.current.includes(route.path)) {
                this.matched.push(route)
                if (route.children) {
                    this.match(route.children)
                }
                return
            }
        }
    }
}
```

```
# krouter-view.js

export default {

    name: 'RouterView',
    // functional: true,
    props: {
        name: String,
        default: 'default',
    },

    render(h) {
        // 标记当前router-view深度
        this.$vnode.data._routerView = true

        let depth = 0
        let parent = this.$parent
        while(parent) {
            let vnodeData = parent.$vnode && parent.$vnode.data
            if (vnodeData) {
                if (vnodeData._routerView) {
                    depth++
                }
            }

            parent = parent.$parent
        }

        let component = null
        const route = this.$router.matched[depth]
        if (route) {
            component = route.component
        }
        return h(component)
    }
}
```

## 第二题：实现vuex的getters

想到了用computed处理，没想到用Object.defineProperty来定义get，也参考了老师的写法

```
# kvuex.js

class Store {
    constructor(options) {
        this.$options = options
        this._wrappedGetters = options.getters
        this.getters = {}
        
        const computed = {}
        const store = this      // 保存指针
        for (let key in this._wrappedGetters) {
            let fn = store._wrappedGetters[key]
            computed[key] = function() {
                return fn.call(this, store.state)
            }

            Object.defineProperty(store.getters, key, {
                get: () => store._vm[key]
            })
        }

        // 使state中的数据成为响应式数据
        this._vm = new Vue({
            data: {
                $$state: options.state,
            },
            computed: computed
        })

...
```